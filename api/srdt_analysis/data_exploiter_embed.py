from srdt_analysis.elastic_handler import ElasticIndicesHandler
from srdt_analysis.chunker import Chunker
from srdt_analysis.collections import AlbertCollectionHandler
from srdt_analysis.constants import BASE_URL_CDTN
from srdt_analysis.logger import Logger
from srdt_analysis.models import (
    Chunk,
    ChunkerContentType,
    CollectionName,
    Document,
    DocumentData,
    DocumentsList,
    FormattedTextContent,
)
import math
from typing import TypeVar

T = TypeVar("T")


def make_batches(elements: T, n) -> list[T]:
    m = math.ceil(len(elements) / n)
    batches: list[T] = []
    for i in range(m):
        batches.append(elements[i * n : (i + 1) * n])
    return batches


class BaseDataExploiter:
    def __init__(self):
        self.chunker = Chunker()
        self.albert = AlbertCollectionHandler()
        self.logger = Logger("BaseDataExploiter")

    def get_content(self, _doc: Document) -> FormattedTextContent:
        raise NotImplementedError("Subclasses should implement this method")

    def process_documents(
        self,
        data: DocumentsList,
        chunker_content_type: ChunkerContentType,
    ) -> list[Chunk]:
        chunk_list: list[Chunk] = []

        for doc in data:
            content = self.get_content(doc)
            chunks = self.chunker.split(content, chunker_content_type)
            doc_data = self.create_document_data(doc, content, chunks)

            for idx, ds in enumerate(doc_data["content_chunked"]):
                chunk_list.append(
                    {
                        "content": ds.page_content,
                        "metadata": {
                            "idx": idx,
                            "id": doc_data["cdtn_id"],
                            "initial_id": doc_data["initial_id"],
                            "url": doc_data["url"],
                            "source": doc_data["source"],
                            "title": doc_data["title"],
                        },
                    }
                )

        # run batches of 64 chunks to get embeddings
        batches = make_batches(chunk_list, 64)

        for docs in batches:
            contents = [doc["content"] for doc in docs]
            embeddings = self.albert.embeddings(contents)

            for doc, emb in zip(docs, embeddings):
                doc["embedding"] = emb

        return chunk_list

    def create_document_data(self, doc, content, content_chunked) -> DocumentData:
        return {
            "cdtn_id": doc.cdtn_id,
            "initial_id": doc.initial_id,
            "title": doc.title,
            "content": content,
            "content_chunked": content_chunked,
            "url": BASE_URL_CDTN
            + "/"
            + self._get_path_from_collection_name(doc.source)
            + "/"
            + doc.slug,
            "source": doc.source,
            "idcc": doc.idcc,
        }

    def _get_path_from_collection_name(self, collection_name: CollectionName) -> str:
        mapping: dict[CollectionName, str] = {
            "code_du_travail": "code-du-travail",
            "fiches_service_public": "fiche-service-public",
            "page_fiche_ministere_travail": "fiche-ministere-travail",
            "information": "information",
            "contributions": "contribution",
            "contributions_idcc": "contribution",
        }
        return mapping[collection_name]


class ArticlesCodeDuTravailExploiter(BaseDataExploiter):
    def get_content(self, doc: Document) -> FormattedTextContent:
        return doc.text


class FichesMTExploiter(BaseDataExploiter):
    def get_content(self, doc: Document) -> FormattedTextContent:
        return "".join(
            section.get("html", "") for section in doc.document.get("sections", [])
        )


class FichesSPExploiter(BaseDataExploiter):
    def get_content(self, doc: Document) -> FormattedTextContent:
        return doc.text


class PageInfosExploiter(BaseDataExploiter):
    def get_content(self, doc: Document) -> FormattedTextContent:
        markdown = ""
        for content in doc.document.get("contents", []):
            for block in content.get("blocks", []):
                if block.get("type") == "markdown":
                    markdown += block.get("markdown", "")
        return markdown


class PagesContributionsExploiter(BaseDataExploiter):
    def get_content(self, doc: Document) -> FormattedTextContent:
        return doc.document["content"]
